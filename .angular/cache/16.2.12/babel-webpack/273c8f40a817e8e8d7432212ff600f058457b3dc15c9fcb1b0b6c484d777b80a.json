{"ast":null,"code":"import { of } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class ApiCallService {\n  constructor(http) {\n    this.http = http;\n    //private reqUrl = 'me-api.ysojs.se';  // URL to web api\n    this.response1 = '';\n    // users : User[] = [];\n    // ------------------------------- Methods\n    // Initial call onInit\n    // ngOnInit(): void {\n    // };\n    // getUsers():Observable<User[]> {\n    //   const users1 = of(this.users);\n    //   return users1;\n    // }\n    this.fetchCall = function (dataObj, url, method, callback, token = null, thisObj = null\n    // maxTime = 5000\n    ) {\n      var result; // The result data\n      var res; // The result\n      var theBody; // The body\n      // Fetch body\n      theBody = {\n        body: JSON.stringify(dataObj),\n        headers: {\n          'content-type': 'application/json',\n          'x-access-token': token\n        },\n        method: method\n        // signal: app.ajax.signal // Controller signal for aborting fetch\n      };\n\n      if (method == 'GET') {\n        theBody = {\n          headers: {\n            'content-type': 'application/x-www-form-urlencoded',\n            'x-access-token': token\n          },\n          method: method\n          // signal: app.ajax.signal // Controller signal for aborting fetch\n        };\n      }\n\n      fetch(url, theBody).then(function (response) {\n        // Return response\n        return response.json();\n      }).then(function (result) {\n        // console.log(result);\n        var res; // The result\n        if (result.errors) {\n          // console.log('Error response: ');\n          // console.log(result.errors.title);\n          // console.log(result.errors.detail);\n          if (result.errors.status == 500) {\n            res = \"Status 500, database error. \";\n            res += \"Data not accepted. Perhaps a duplicate.\";\n            // res += result.errors.title;\n          }\n\n          if (result.errors.status == 401) {\n            res = \"Status 401, database error. \";\n            res += result.errors.title;\n          }\n        }\n        if (result.data) {\n          res = result.data.message;\n        }\n        // Send callback result\n        callback(thisObj, res, result);\n      });\n    };\n  }\n  reqCall(method, url, callback2, thisObj, params = null, header = null) {\n    console.log('Server call via XMLHttpRequest');\n    // console.log(callback1);\n    var request;\n    var res = '';\n    if (window.XMLHttpRequest) {\n      request = new XMLHttpRequest();\n    }\n    if (!window.XMLHttpRequest) {\n      return 'NoXMLHttpRequest';\n    }\n    try {\n      request.onreadystatechange = function () {\n        // console.log(request);\n        if (request.readyState == 4) {\n          // res contains the data from the server\n          res = request.responseText;\n          // Send the result to the callback\n          this.response1 = res;\n          return callback2(thisObj, res);\n        }\n      };\n      request.open(method, url, true);\n      // Set multiple headers\n      if (header) {\n        if (!Object(header)) {\n          return false;\n        }\n        // Check what the header includes\n        // header.forEach((element) => console.log(element));\n        // Set the headers\n        for (var key in header) {\n          request.setRequestHeader(key, header[key]);\n        }\n        //request.setRequestHeader('Content-Type', header);\n      }\n\n      request.send(params);\n      res = request.responseText;\n      this.response1 = res;\n      return callback2(thisObj, res);\n    } catch (e) {\n      console.log('Unable to connect to the server');\n      console.log(e);\n      return 'incompleted';\n    }\n  }\n  callback1(res) {\n    console.log(res);\n    return res;\n  }\n  // /** GET from the server w angular http */\n  // getCall(): Observable<apiData> {\n  //     return this.http.get(this.reqUrl)\n  //       .pipe(\n  //         // tap(_ => this.log('fetched heroes')),\n  //         catchError(this.handleError('getCall', []))\n  //   );\n  // }\n  /**\n   * Handle Http operation that failed.\n   * Let the app continue.\n   *\n   * @param operation - name of the operation that failed\n   * @param result - optional value to return as the observable result\n   */\n  handleError(operation = 'operation', result) {\n    return error => {\n      // TODO: send the error to remote logging infrastructure\n      console.error(error); // log to console instead\n      // TODO: better job of transforming error for user consumption\n      // this.log(`${operation} failed: ${error.message}`);\n      // Let the app keep running by returning an empty result.\n      return of(result);\n    };\n  }\n  static #_ = this.ɵfac = function ApiCallService_Factory(t) {\n    return new (t || ApiCallService)(i0.ɵɵinject(i1.HttpClient));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ApiCallService,\n    factory: ApiCallService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["of","ApiCallService","constructor","http","response1","fetchCall","dataObj","url","method","callback","token","thisObj","result","res","theBody","body","JSON","stringify","headers","fetch","then","response","json","errors","status","title","data","message","reqCall","callback2","params","header","console","log","request","window","XMLHttpRequest","onreadystatechange","readyState","responseText","open","Object","key","setRequestHeader","send","e","callback1","handleError","operation","error","_","i0","ɵɵinject","i1","HttpClient","_2","factory","ɵfac","providedIn"],"sources":["/mnt/c/Users/ylva/dbwebbkurser/jsramverk/2023version/yso/projektJs2024/frontendProj/src/app/api-call.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\nimport { Observable, of } from 'rxjs'; \n\n// import { MessageService } from './message.service';\n\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\n\nimport { catchError, map, tap } from 'rxjs/operators';\n\nimport { apiData } from './apiData';\n\nimport { User } from './User';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ApiCallService {\n\n  constructor(private http: HttpClient) { }\n\n  //private reqUrl = 'me-api.ysojs.se';  // URL to web api\n\n  public response1 = '';\n\n  // users : User[] = [];\n\n  // ------------------------------- Methods\n  // Initial call onInit\n  // ngOnInit(): void {\n  // };\n\n  // getUsers():Observable<User[]> {\n  //   const users1 = of(this.users);\n  //   return users1;\n  // }\n\n  fetchCall = function( \n      dataObj,\n      url,\n      method,\n      callback,\n      token = null,\n      thisObj = null\n      // maxTime = 5000\n  ) {\n    var result; // The result data\n    var res; // The result\n    var theBody; // The body\n\n    // Fetch body\n    theBody = {\n        body: JSON.stringify(dataObj),\n        headers: {\n            'content-type': 'application/json',\n            'x-access-token': token\n        },\n        method: method,\n        // signal: app.ajax.signal // Controller signal for aborting fetch\n    };\n\n    if (method == 'GET') {\n        theBody = {\n            headers: {\n                'content-type': 'application/x-www-form-urlencoded',\n                'x-access-token': token\n            },\n            method: method,\n            // signal: app.ajax.signal // Controller signal for aborting fetch\n        };\n    }\n\n    fetch(url, theBody)\n    .then(function (response) {\n\n        // Return response\n        return response.json();\n\n    }).then(function(result) {\n        // console.log(result);\n        var res;// The result\n\n        if (result.errors) {\n            // console.log('Error response: ');\n            // console.log(result.errors.title);\n            // console.log(result.errors.detail);\n\n            if (result.errors.status == 500) {\n                res = \"Status 500, database error. \";\n                res += \"Data not accepted. Perhaps a duplicate.\";\n                // res += result.errors.title;\n            }\n\n            if (result.errors.status == 401) {\n                res = \"Status 401, database error. \";\n                res += result.errors.title;\n            }\n        }\n\n        if (result.data) {\n            res = result.data.message;\n        }\n\n        // Send callback result\n        callback(thisObj, res, result);\n    });\n    }\n    \n\n    reqCall(method, url, callback2, thisObj, params = null, header = null) {\n      console.log('Server call via XMLHttpRequest');\n      // console.log(callback1);\n      var request;\n      var res = '';\n  \n      if (window.XMLHttpRequest) {\n          request = new XMLHttpRequest();\n      }\n      if (!window.XMLHttpRequest) {\n          return 'NoXMLHttpRequest';\n      }\n  \n      try {\n          request.onreadystatechange = function() {\n            // console.log(request);\n            if (request.readyState == 4) {\n                // res contains the data from the server\n                res = request.responseText;\n  \n                // Send the result to the callback\n                this.response1 = res;\n                return callback2(thisObj,res);\n            }\n          };\n          request.open(method, url, true);\n\n          // Set multiple headers\n          if (header) {\n              if (!Object(header)) {\n                return false;\n              }\n              // Check what the header includes\n              // header.forEach((element) => console.log(element));\n\n              // Set the headers\n              for (var key in header) {\n                request.setRequestHeader(key, header[key]);\n              }\n\n              //request.setRequestHeader('Content-Type', header);\n          }\n          request.send(params);\n          res = request.responseText;\n          this.response1 = res;\n          return callback2(thisObj,res);\n          \n          \n      } catch (e) {\n          console.log('Unable to connect to the server');\n          console.log(e);\n          return 'incompleted';\n      }\n    }\n  \n    callback1(res) {\n      console.log(res);\n      return res;\n    }\n\n    // /** GET from the server w angular http */\n    // getCall(): Observable<apiData> {\n    //     return this.http.get(this.reqUrl)\n    //       .pipe(\n    //         // tap(_ => this.log('fetched heroes')),\n    //         catchError(this.handleError('getCall', []))\n    //   );\n    // }\n    \n            \n    /**\n     * Handle Http operation that failed.\n     * Let the app continue.\n     *\n     * @param operation - name of the operation that failed\n     * @param result - optional value to return as the observable result\n     */\n    private handleError<T>(operation = 'operation', result?: T) {\n      return (error: any): Observable<T> => {\n\n        // TODO: send the error to remote logging infrastructure\n        console.error(error); // log to console instead\n\n        // TODO: better job of transforming error for user consumption\n        // this.log(`${operation} failed: ${error.message}`);\n\n        // Let the app keep running by returning an empty result.\n        return of(result as T);\n      };\n    }\n\n    \n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}