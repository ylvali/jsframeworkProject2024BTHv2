{"ast":null,"code":"import { of } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let ApiCallService = /*#__PURE__*/(() => {\n  class ApiCallService {\n    constructor(http) {\n      this.http = http;\n      //private reqUrl = 'me-api.ysojs.se';  // URL to web api\n      this.response1 = '';\n      // users : User[] = [];\n      // ------------------------------- Methods\n      // Initial call onInit\n      // ngOnInit(): void {\n      // };\n      // getUsers():Observable<User[]> {\n      //   const users1 = of(this.users);\n      //   return users1;\n      // }\n      this.fetchCall = function (dataObj, url, method, callback, token = null, thisObj = null\n      // maxTime = 5000\n      ) {\n        var result; // The result data\n        var res; // The result\n        var theBody; // The body\n        // Fetch body\n        theBody = {\n          body: JSON.stringify(dataObj),\n          headers: {\n            'content-type': 'application/json',\n            'x-access-token': token\n          },\n          method: method\n          // signal: app.ajax.signal // Controller signal for aborting fetch\n        };\n\n        if (method == 'GET') {\n          theBody = {\n            headers: {\n              'content-type': 'application/x-www-form-urlencoded',\n              'x-access-token': token\n            },\n            method: method\n            // signal: app.ajax.signal // Controller signal for aborting fetch\n          };\n        }\n\n        fetch(url, theBody).then(function (response) {\n          // Return response\n          return response.json();\n        }).then(function (result) {\n          // console.log(result);\n          var res; // The result\n          if (result.errors) {\n            // console.log('Error response: ');\n            // console.log(result.errors.title);\n            // console.log(result.errors.detail);\n            if (result.errors.status == 500) {\n              res = \"Status 500, database error. \";\n              res += \"Data not accepted. Perhaps a duplicate.\";\n              // res += result.errors.title;\n            }\n\n            if (result.errors.status == 401) {\n              res = \"Status 401, database error. \";\n              res += result.errors.title;\n            }\n          }\n          if (result.data) {\n            res = result.data.message;\n          }\n          // Send callback result\n          callback(thisObj, res, result);\n        });\n      };\n    }\n    reqCall(method, url, callback2, thisObj, params = null, header = null) {\n      console.log('Server call via XMLHttpRequest');\n      // console.log(callback1);\n      var request;\n      var res = '';\n      if (window.XMLHttpRequest) {\n        request = new XMLHttpRequest();\n      }\n      if (!window.XMLHttpRequest) {\n        return 'NoXMLHttpRequest';\n      }\n      try {\n        request.onreadystatechange = function () {\n          // console.log(request);\n          if (request.readyState == 4) {\n            // res contains the data from the server\n            res = request.responseText;\n            // Send the result to the callback\n            this.response1 = res;\n            return callback2(thisObj, res);\n          }\n        };\n        request.open(method, url, true);\n        // Set multiple headers\n        if (header) {\n          if (!Object(header)) {\n            return false;\n          }\n          // Check what the header includes\n          // header.forEach((element) => console.log(element));\n          // Set the headers\n          for (var key in header) {\n            request.setRequestHeader(key, header[key]);\n          }\n          //request.setRequestHeader('Content-Type', header);\n        }\n\n        request.send(params);\n        res = request.responseText;\n        this.response1 = res;\n        return callback2(thisObj, res);\n      } catch (e) {\n        console.log('Unable to connect to the server');\n        console.log(e);\n        return 'incompleted';\n      }\n    }\n    callback1(res) {\n      console.log(res);\n      return res;\n    }\n    // /** GET from the server w angular http */\n    // getCall(): Observable<apiData> {\n    //     return this.http.get(this.reqUrl)\n    //       .pipe(\n    //         // tap(_ => this.log('fetched heroes')),\n    //         catchError(this.handleError('getCall', []))\n    //   );\n    // }\n    /**\n     * Handle Http operation that failed.\n     * Let the app continue.\n     *\n     * @param operation - name of the operation that failed\n     * @param result - optional value to return as the observable result\n     */\n    handleError(operation = 'operation', result) {\n      return error => {\n        // TODO: send the error to remote logging infrastructure\n        console.error(error); // log to console instead\n        // TODO: better job of transforming error for user consumption\n        // this.log(`${operation} failed: ${error.message}`);\n        // Let the app keep running by returning an empty result.\n        return of(result);\n      };\n    }\n    static #_ = this.ɵfac = function ApiCallService_Factory(t) {\n      return new (t || ApiCallService)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ApiCallService,\n      factory: ApiCallService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ApiCallService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}